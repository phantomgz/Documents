# UG103.5: Application Development Fundamentals: Security

This document introduces some basic security concepts, including network layer security, trust centers, and application support layer security features. It then discusses the types of standard security protocols available in EmberZNet PRO. Coding requirement s for implementing security are reviewed in summary. finally, information on implementing Zigbee Smart Energy security is provided.

介绍基本的安全原理, 包括网络层安全, 信任中心, 应用层支持安全特性. 论及在 EmberZNet 中可用的标准安全协议的类型. 在summary 中回顾安全实现的编码要求. 最后, 提供安全Zigbee Smart Energy 的实现信息.

## 1. Introduction

Security is a major concern in the Zigbee architecture. Although Zigbee uses the basic security elements in IEEE 802.15.4\(for example, Advanced Encryption Standard\(AES\) encryption and Counter with CBC-MAC\(CCM\) security modes\), it expands upon this with:

* 128-bit AES encryption algorithms
* String, U.S. National Institute of Standards and Technology\(NIST\)-approved security
* Defined key types \(link, network\)
* Defined key setup and maintenance
* keys can be hardwired into an application
* CCM\* \(Unified/simpler mode of operation\)
* Trust centers
* Security that can be customized for the application

As the following figure illustrates, the security services provider block interactions with both the application and network layers\(安全服务提供程序阻止与应用程序和网络层的交互\).

Zigbee now supports a single defined security mode called **Standard Security**. Various policies exist within that mode to control how devices behave or interact on the network. Earlier versions of the Zigbee standard utilized modes know as **Residential Security** and **High Security**. These have been deprecated.

**Note:** IEEE 802.16.4 MAC-level security is **not** used by Zigbee and is therefore not supported by EmberZNet PRO and not described here. Zigbee implements message security at the network and application layers.

![](.gitbook/assets/image%20%281%29.png)

This document first describes some basic security concepts, including network layer security, trust centers, and application support layer security features. It then discusses the types of standard security protocols available in EmberZNet PRO. Coding requirements for implementing security are reviewed in summary. Finally, information on implementing Zigbee Smart Energy security is provided. Details may be found in document AN714, Smart Energy ECC-Enabled Device Setup.

Those already familiar with Zibee security concepts can jump to section 4.Zigbee Smart Energy\(ZSE\) Security.

## 2. Concepts

### 2.1 Network Layer Security

This section describes how Zigbee implements security at the network layer, which applies to standard security. Network security provides security independent of the applications that may be running on a Zigbee node. All Zigbee-certified devices must use network layer security. It provides the basic access control for controlling what nodes are allowed to participate in a particular Zigbee network. For application-controlled security, see section [2.4 APS Layer Security](ug103.5-application-development-fundamentals-security.md).

#### 2.1.1 The Network Key

Network security uses a network-wide key for encryption and decryption. All devices that are authorized to join the network have a copy of the key and use it to encrypt and decrypt all network messages. The network key also has a sequence number associated with it ot identify a particular instance of the key. When the network key is updated, the sequence number is incremented to allow devices to identify which instance of the network key has been used to secure the packet data. The sequence number ranges from 0 to 255. When the sequence number reaches 255, it wraps back to 0.

**Note:** All Zigbee keys are 128-bits in length.

All devices that are part of a secured Zigbee network have a copy of the network key.

#### 2.1.2 Hop-by-Hop Security

It is important to note that network security in Zigbee is done on a hop-by-hop basis. Each router that relays an encrypted packet first verifies that it is a valid encrypted packet before any more processing is done. A tourter authenticates the packet by executing the Zigbee decryption mechanism and verifying the packet integrity. It then re-encrypts the packet with its own network parameters\(such as source address and frame counter\) before sending the message to the next hop. Without this protection, an attacker could replay a message into the network that would be routed through serveral devices, thereby consuming network resources. Using hop-by-hop security allows a router to block attempts to inject bad traffic into the network.

#### 2.1.3 Packet Security

A packet secured at the network layer is composed of the elements shown in the following figure.

![](.gitbook/assets/image%20%282%29.png)

#### 2.1.4 Auxiliary Header

The auxiliary header contains data about the security of the packet that a receiving mode uses to correctly authenticate and decrypt the packet. This data includes the type of key used, the sequence number\(if it is the network key\), the IEEE address of the device that secured the data, and the frame counter.

#### 2.1.5 Authentication and Encryption

Zigbee uses a 128-bit symmetric key to encrypt all transmissions at the network layer using AES-128. The network and auxiliary headers are sent in the clear but authenticated, while the network payload is authenticated and encrypted. AES-128 is used to create a hash of the entire network portion of the message \(header and payload\), which is appended to the end of the message. This hash is known as the **Message Integrity Code\(MIC\)** and is used to authenticate the message by insuring it has not been modified. A receiving device hashes the message and verifies the calculated MIC against the value appended to the message. Alterations to the message invalidate the MIC and the receiving node will discard the message entirely.

**Note:** Zigbee uses a 4-byte MIC.

#### 2.1.6 The Network Security Frame Counter

A frame counter is included in the auxiliary headers as a means of protecting against replay attacks. All devices have their own outgoing frame counter and they maintain a list of their neighbor's and children's frame counters. Every time a device sends a packet, it increments its outgoing frame counter. A receiving device verifies that the frame counter of the sending device has increased from the last value that it saw. if it has not increased, the packet is silently discarded. If the receiving device is not the final destination, the packet is decrypted and modified to include the routing devices's frame counter. The packe is then re-encrypted and sent along to the next hop.

The frame counter is 32 bits and may not wrap to zero. The network key can be updated before the frame counter reaches its maximum value. When that occurs, the frame counter may be reset to zero if the local device's value is above 0x80000000.

#### 2.1.7 Unencrypted Network Data

All normal network datagrams are required to have network security and a valid frame counter. The only exception is during joining, when devices do not yet have the network key. In that case a joining device's messages are relayed through its parent until it is fully joined and authenticated. Any other messages that are received without network layer security are silently discarded.

### 2.2 Trust Center Network

Authentication in a secure network may be controlled by means of a central authority known as a trust center. All devices entering the network are temporarily joined to the network until the trust center is contacted and decides whether or not to allow the new device into the network. The parent of the newly joined device acts as a relay between the trust center and the joining device. Only authentication messages can be sent to or from the device until it is fully joined and authenticated.

The trust center has the option of doing one of three things when a device joins:

* Send a copy of the current network key, which the parent relays to the joining device.
* Send the parent a command to remove the device from the network, thereby disallowing it from joining.
* Ignore the request. Parents will silently remove the device from the network if it does not receive a network key within 2 seconds.

Once the node has the network key, it is considered fully joined and authenticated, and may communicate with any device on the network.

A network operating with a trust center always needs a trust center to authenticate any new devices. Normal messages between two devices do not require the trust center to get involved.

### 2.3 Distributed Trust Center Networks

Networks may be formed without a centralized authentication. These networks are call **Distributed Trust Center Networks**. In this case, any router may authorized and authenticate new devices that wish to join.

These networks offer a simpler mechanism for adding devices to the network at the sslight expense of a less secure network.

The decision to use a Distributed Trust Center Network or a Trust Center network is done at the time the network is formed. There is no way to change this decision after the network has been started.

### 2.4 APS Layer Security

This section describes how Zigbee implements security at the **Application Support\(APS\)** layer.

#### 2.4.1 End-to-End Security

APS security is intended to provide a way to send messages securely within a Zigbee network such that no other device can decrypt the data except the source and destination. This is different than network security, which provides only hop-by-hop security. In that case every device that is part of the network and hears the packet being relayed to its destination and decrypts it.

APS security uses a shared key that only the source and destination know about, thus providing end-to-end security.

Both APS layer and network layer encryption can be used simultaneously to encrypt the contents of a message. In that case APS layer security is applied first, and then network layer security.

A packet secured at the APS Layer is composed of the elements shown in the following figure.

![](.gitbook/assets/image%20%284%29.png)

#### 2.4.2 Link Keys

APS security uses a peer-to-peer key known as the link key. Both devices must have already established this key with one another before sending APS-secured data. There are two types of link keys: trust center link keys and application link keys.

**Trust Center Link Keys**

The **trust center link key** is a special link key in which one of the partner devices is the trust center. The stack used this key to send and receive APS command messages to and from the trust center. The application may also use this key to send APS-encrypted data messages.

All devices in a Zigbee network must have link keys, In a Trust Center network, the devices must have a Trust Center Link Key. In a Distributed Trust Center Network, this key is called a **Distributed Trust Center link key**.

**Application Link Keys**

Application link keys are shared keys that may be established between any two nodes in the network, where neither device is a trust center. They may be used to add additional security to messages being sent to or from the application running on a node. Devices can have a different application link key for each device with which they communicate.

A device may preconfigure an application link key or request a link key between itself and another device. In the latter case it issues a request to the trust center encrypted with its trust center link key\(发送一个用它的信任中心key加密的请求到信任中心.\). The trust center acts as a trusted third party to both devices, so they can securely establish communications with one another. This is discussed further in section \[3.2.4 Application Link Keys\]. The process for establishing an application link key is illustrated in the following figure.

![](.gitbook/assets/image%20%285%29.png)

#### 2.4.3 Unencrypted APS Data

APS layer security operates independently of network layer security. It is required for certain security messages\(APS commands\) sent to and from the trust center by the Zigbee stack.

Unlike network security, APS security for application messages is optional. Application messages are not automatically encrypted at the APS layer and are not ignored on the receiving side if they do not have APS encryption. Individual applications may choose whether to accept or reject messages that do not have APS layer security. For example, the Smart Energy profile describes what Zigbee Cluster messages are required to have security.

## 3. Standard Security

### 3.1 Overview

Standard security, introduced in the Zigbee 2007 specification along with Zigbee PRO, is the security model being used in all Zigbee application profiles and in Zigbee 3.0. It is the only security model supported by the EmberZNet stack libraries.

Standard security uses network keys and link keys to encrypt data at the network and application layers, respectively. The application support\(APS\) layer security allows the trust center to securely transport the network key to joining or rejoining nodes, and it optionally allows applications to add additional security to their messages. Network\(NWK\) layer security is used to secure all traffic sent ton a Zigbee network, with the exception of basic MAC layer communication. such as association, data requests\(polling\), and MAC ACKs.

### 3.2 Use of Key in Standard Security

Standard security defines different keys used for securing data in different ways. All keys are 128-bit symmetric and my or may not be used for encrypting/decrypting packets.

#### 3.2.1 Network Key

This is the network-wide key used to secure transmissions at the network layer. Standard security requires the use of a shared network key among all devices in the network. The trust center may periodically update and switch to a new network key. The trust center may use either a broadcast update or a unicast update. In the broadcast case, the trust center first broadcasts a new network key encrypted with the old network key. In the unicast case, the trust center sends a new network key to each device encrypted with that device's corresponding Trust Center Link Key.

In both cases, the trust center later tells all devices to switch to using  the new network key. the new network key has a sequence number that is one higher than the last sequence number.

#### 3.2.2 Trust Center Link Key

This key \(known simply as the link key\) is used for secure end-to-end communications between two nodes, one of which is the trust center. The trust center link key is used in these cases:

1. Encrypting the initial transfer of the network key to a joining node.
2. Encrypting an updated copy of the network key to q rejoining node that does not have the current network key.
3. Routers sending or receiving APS security messages to or from the trust center. These may be updates informing the trust center of a joining or rejoining node, or a command sent by the trust center to a router to perform some security function.
4. Application unicast messages that enable APS encryption, where either the sending or receiving device is the trust center.

The trust center has the option of deciding how to manage the trust center link keys. It may choose unique keys for each device in the network, keys derived from a common piece of shared data \(the IEEE address of the device\), or a global key that is the same for all devices in the network. Trust center link keys may also be negotiated at the application layer using a key establishment protocol link **Certificate-Based key Establishment \(CBKE\)**.

#### 3.2.3 Installation Code Keys

Zigbee 3.0 now has installation code keys, which were previously only available to Smart Energy network. All Zigbee 3.0 certified devices are required to have them, but use in the network is decided by the trust center. Smart Energy networks are required to always use them.

An installation code key is just a preconfigured trust center link key used to enter the Zigbee network and obtain the current network key. Because this unique key must be known to both the joining device and the trust center at the time of network entry, a piece of shareable data known as "installation code" \(sometimes also referred to as the "install code"\) is used to derive the key at both sides. The code can be any arbitrary value of 6, 8, 12, or 16 bytes, followed by a 16-bit CRC \(least significant byte first\) over those bytes.



