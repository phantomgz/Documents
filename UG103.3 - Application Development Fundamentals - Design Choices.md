**UG103.3: Application Development Fundamentals: Design Choices**

Design choices when developing a zigbee solution include:
* How to create the network (form, join, or leave)
* What security models will be used
* What kind of routing optimizations to employ in the network
* How to deliver messages through the network

# 3.0 Zigbee Design Choices

Although the application framework simplifies and abstracts the design process, some design decisions must be make as part of implementation regardless of whether the design is based on the application framework or not. The following design choices are applicable when developing applications for zigbee protocols, including zigbee PRO and zigbee RF4CE:

* Single Network or Multi-Network
* Network Discovery / Commissioning Method
* Route Establishment Method
* Message Delivery Method
* NCP and Host Application Compatibility

## 3.1 Single network vs. Mutli-Network

A single network node is a node that forms or joins one entwork and must leave that network before forming or joining a second network. EmberZNet PRO 4.7 introduced the possibility for a node to be concurrently part of more than one network (this feature is not supported on the EM351)

**Note:** For MeberZNet PRO, multi-network support is limited to two networks. More than two networks may be supported in the future.

Until now, any device required two physical chips to be part of two networks. For instance, a device that is designed to be a gateway between an HA (Home Automation) PAN (personal area network) and an SE (Smart Energy) PAN would join the first network using the first chip and the second network using the second chip. The application had to manage two pieces of hardware, resulting in increased complexity for the hardware and the application desgner.

A multi-network stack removes the 1-to-1 mapping between logical PANs and physical chip, extending it to an n-to-1 mapping. An application for a device with a single chip can be designed to be part of multiple PANs possibly running different security profiles (for instance HA and SE). Use of one instead of two chips results in cost savings from reduced hardware requirements and reduced complexity of the hardware and application code design.

Some applications still require a dual-chip configuration. This configuration is needed if the device needs to be coordinator or router on two networks (see more details below) or if the application needs to operate on two different stacks such as EmberZNet PRO and Silicon Labs Thread.

Multi-networking on a single chip is achieved by timesharing the chip’s only radio on the networks. In other words, the multi-network node resets all the radio parameters between the networks according to a network scheduling algorithm.

There are some restrictions to the roles a node can assume on the networks. Since a coordinator or a router node is expected to keep the radio constantly on listening for incoming packets, a mult-network node can be coordinator or router on only one networ, while it must be a sleepy end device on the other networks.

**Note:** A node can assume any role on one network, but must be a sleepy end device on the other networks.

The networks in which a node participates can be on different channels, different PAN IDs, different short IDS, different profiles, and so on. However, a multi-network node maintains the same EUI64 address across the networks in which it participates. The next sections discuss in more detail the two basic configurations, the first where the multi-network node is a corrdinator or router on one and a sleepy end device on all other networks, and the second where it is a sleepy end device on all networks.

### 3.1.1 Coordinator / Router Network + Sleepy End Device Network(s)

A multi-network node that is a coordinator/router on one network and a sleepy end device on the other networks should spend moust of its time on the coordinator/router network. A network scheduling algorithm seamlessly takes care of switching from one network to the other so that the node is always on the coordinator/router network except for short periods of time. In particular, the node temporarily leaves the coordinator/router network to complete certain transctions on the sleepy end device networks, such as polling/data retrieving from the parent and/or data sending to the parent. These transcations are typically initiated at the application layer. Therefore the application designer should design the application so that the node does not spend too much time away from the coordinator/router network. Having a multi-network node too busy on a sleepy end device network can consistently impact the throughput of the node and in general could delay all the traffic that gets routed through the node on the coordinator/router network.

### 3.1.2 Multiple Sleepy End DEvice Networks

A multi-network node that is a sleepy end device on all networks does not need to keep its radio always on. The node can poll with different polling rates on each network. The node is able to sleep as long as there is no activity on any network.

## 3.2 Network Discovery / Commissioning

Commissiong refers to the process of getting devices into the network. If you have read the discussion of the network joing process in the document UG103.2: Application Development fundamentals: Zigbee, you may recall that, unless a device is acting as coordinator for a PAN, it must request to join an existing network, and that the joining device must scan one or more channels to locate the available networks. However, as the network coordinator has several radio channels from which to choose in forming its PAN, and since the network's PAN ID and Extended PAN are ofen randomized, your application generally requires some intelligence or external mechanism to assist with network discovery and commissioning. Tasks include helping ensure that the device can either join the proper network or receive the desired networ settings from some external source, and ensuring that the device can be removed from the network when either the wrong network is joined by mistake or the device is being migrated to a new installation. Likewise, if yur are designing a device that may act as a zigbee PAN coordinator, it is importan to consider ways in which you can ease the process of network selection for devices looking to enter your coordinator's network.

**Note:** If you are designing an application for use in an official, public zigbee PRO application profile (such as HOME Automation), Silicon Labs recommends that you review the latest published revison of the appropriate zigbee application profile specification (as obtained from <http://www.zigbee.org>) for your target design, to ensure that it meet any profile-specific requirements or best practices for commissioning.

### 3.2.1 Simplifying Network Selection through Extended PAN ID or Channel Mask

Although Extended PAN ID selection by the PAN's coordinator is generally random, a proprietary netwrok deployment may use a specific bitmask of extended PAN IDs as a way to enhance network selection for joining devices. In this model, the coordinator forms a network within this aggreed-upon Extended PAN ID mask, such that joning devices could scan channels for open PANs and limit those outside of the configured Extended PAND ID range. However, this method of enhancing network selection is not feasibe for devices wishing to interoperate on public zigbee PRO profiles with devices from a wide range of manufacturers. Because the public zigbee PRO application profiles do not generally limit their Extended PAN ID selection, another vendor's device may occupy Extended PAN IDs outside of the limiting bitmask that you're chosen.

Similarly, although 2.4 GHz zigbee networks can occupy any of 16 different channels, the joining device may be able to limit its mask of channels to scan. The expected network might be a proprietary design in which the coordinator has chosen to confine its channel selection to only a few channels within a preconfigured mask.  Alternatively, the application profile upon which one or more endpoints of the included devices is based may require constraining the network's channel selection to a specific set of channels. For instance, both the zigbee PRO SE and HA application profiles require that preference be given when forming a network to channels outside of the most commonly used Wi-Fi channel allocations (channels 1, 6 and 11 in the IEEE802.11 range), which allows the joining device to confine its channel scan to zigbee channels 11, 14, 15, 19, 20, 24, and 25. Note that AFV2 uses the Network Find plugin (if enabled) to configure the channel mask for the device when joining or forming a network. If using Application Builder to configure your application, make sure to review the Channel Mask and other radio parameter settings in the configuration dialog for the Network Find plugin. If you are not using the Network Find plugin or your application is not based on AFV2, your application code needs to use its own method for ensuring that a preferred channel mask and any other perferred network parameters are enforced during scanning, joining or forming of networks.

### 3.2.2 Permit Joining Control

Devices looking to join a network generally only consider those PANs that are open to new devices (in other words, they permit joining), and devices must not leave their _permitJoining_ flag permanently set, at the risk of failing zigbee PRO compliance testing for public profiles and manufacturer-specific profiles (MSPs). Therefore, devices, especially the PAN coordinator, must ensure that they can enable the _permitJoining_ flag locally for at least some limited time when new devices need to be added to the network. This enabling generally must come from some external stimulus, which will depend on the physical capabilities of a device. If a button or serial interface is available to the device, this us usually an appropriate stimulus to enable _permitJoining_. However, if the device doesn't have an external input to act as this stimulus, other methods must be considered. One possibility is to have the device enable _permitJoining_ for a limited time when it is first powered on. Another option is to cause _permitJoining_ to be enabled when a particular message is received by the node over the air.

With regard to the latter method, while it is possible for the application to make a local change to its onw _permitJoining_ state through a local call to the _emberPermitJoining()_ API or _permitJoining_ EZSP command, it is also possible to send a standard request through the ZDO (zigbee Device Object), which is implemented intrinsically by the stack, to a zigbee node to ask it to change its _permitJoining_ state. When a ZDO Permit Joining Request is received over the air for endpoint 0 (the ZDO) on application prfile 0x0000 (the zigbee Device Profile), the stack automatically alters the _permitJoining_ state on the device. A unicast or broadcast of this request provides a standard way to change the permissions of the network remotely for some or all devices, respectively. For sample code that implements this request, please refer to the _emberPermitJoiningRequest()_ API found in the "app/util/zigbee-framework/zigbee-device-common.h" file from your EmberZNet PRO installation.

Once the network contains at least one node within range of the joining device that permits joining. the joining device should be able to detect it as joinable through the stack's native _emberNetworkFoundHandler()_ / ezspNetworkFoundHandle()_ callback or its _emberJoinableNetworkFoundHandler()_ callback provided by the form-and-join utilities found in "app/util/common/form-and-join.h", which are used by the AFV2 architecture. (See the AFV2's "Network Find" plugin or "Network Steering" plugin for a recommended implementation.)

### 3.2.3 Avoiding Unintended Consequences in the Commissioning Process

Once your joining device does find a joinable network and attempts to join it, the application or the installer must determine if it is the "correct" network, meaning the intended one rather than some other, arbitrary PAN that happended to be within range and permitting joining. The joining and subsequent authentication process, which involves acquisition of the cureent NWK (network) layer encryption key for the PAN, can fail in a variety of ways, even when joining the intended network. Therefore, permanently excluding networks where a jon was attempted but failure in joining/authenticating has occurred is not necessarily the best practice. Similarly, depending on the security expectations of your joining device, it may be possible for it to successfully join a network that realyy isn't the correct one at all, so permanently settling into a network simply becuase the stack sends an _EMBER_NETWORK_UP_ signal, indicating that the device was successfully joined and authenticated into the network, may not be sufficient either. The appropriate criteria for determining whether the attermpted network is the correct one varies based on your design requirements, especially where security is concerned.

If you are designing a device for use in a zigbee PRO SE (Smart Energy) network, a complex pre-authorization process is required before the device can successfully enter the network. See the document **UG103.5: Application Development Fundamentals: Security** for more information. Assuming that the requirement for pre-authorization has been met in the target network, joining the wrong network accidentally should be virtually impossible as the joining device won't acdept the NWK key delivery if it arrives unencrypted or encrypted with a different **APS (Application Support)** link key.

However, even with the SE security model, the joining node may still need to acount for the fact that an unreliable link or other communiction problem, especially if it involves the PAN's trust center, may cause the delivery of the NWK key from the trust center to fail, even in the correct network. Thus, if ajoinable network is detected but the subsequent joining and authentication fails with _EmberStatus_ of _EMBER_NO_NETWORK_EKY_RECEIVED_ (meaning the NWK key didn't arrive successfully), _EMBER_JOIN_FAILED_ (which could signify that the Association Response for the join wasn't received successfully), or _EMBER_NO_BEACONS_ (meaning that the ASSOCIATION Request on the chosen network failed to get an answer), you may want to retry the joining process on that PAN again either immediately or later, in case the first attempt failed due to some temporary disruption. If the joining or authentication process continues to fail on the chosen PAN, consider attemping joining a different joinable network, provided one is available to your device, as the failures may be an indication that this is simply the wrong network.

In networks utilizing an HA (HOME Automation) security model with a common, preconfigured APS link key used to pass a randomly generated NWK key, there is significant risk of joining the wrong network by accident if multiple joinable networks happend to exist within range of the joining device, as the security settings among these networks are common to nearly all HA networks rather than being unique for each incoming node. Note that it is possible for HA networks to use a different preconfigured link key, but this key must somehwo be communicated to the new node prior to its joining the network. Thus, you should take extra care in your application design to ensure that, once you enter a PAN successfully, it is realy the intended one. This typically involves some kind of "join and verify" process for each available network that accepts your device, which means sending some sourt of well-defined over-the-air message with an expected response to indicate joining of the correct network; this rsponse may be another over-the-air message or may be some kind of detectable behavior by another part of the system.

An example of each method is descrbed in the following table, beginning when a new node joins the candidate network:

**Table 3.1. Join-and-Verify Methods**

|Triggering Event | Success | Exception |
|---|---|---|
|Example1|
|Node sends broadcast ZDO Match Descriptor Request for one or more target clusters that are important to the node's operation. | ZDO Match Descriptor Response received from one or more remote nodes.| No matches found; node goes to the next network candidate. |

|   |
|---|
|Caveats|
|As this verification process detects only devices that support the desired clusters, it can succeed when the joining node has entered a network with the same kind of security model and same kind of cluster capabilities as the intended network. For example, the garage door opener may join an arbitrary network with a garage door to control, but not the intended one. If this happens, the system must somehow detect the condition and instruct the new node to leave the current network and find a different one. |
|This process only succeeds when at least one other node with the matching services has already been joined to the network. This introduces a commissioning requirement for the order in which devices must be joined, which must be communicated to the installer.|

|   |   |   |
|---|---|---|
|Example 2|
|Step 1: Node sends a unicast ZDO Match Descriptor Request to the network coordinator (node ID 0x0000), trying to match a device with support for ZCL Identify server cluster. | Node receives a ZDO Match Descriptor Response from the coordinator. | No Response; node goes to the next network candidate. |

|   |
|---|
|Caveats |
|In addition to the required instructions for the system, this method depends on having the coordinator accessible whenever a node is joined to the network. This is generally the case, as the coordinator is typically fulfilling the role of trust center to provide central authentication for each new node. |
|This method also requires having some system-accessible stimulus availabel on the joining node to enable it to change networks.|

|   |   |   |
|---|---|---|
|Example 3 |
|PAN's Trust Center receives the _TrustCenterJoinHandler_ callback for the joining device.| PAN's trust Center notifies the system through visual or audible indications on the Trust Center or some dedicated user interface such as a network PC. | System does not get the expected indication; system acts on the node so that is leaves the network and goes to the next candidate.|

|   |
|---|
|Caveats|
|This example does not require that the joining node's application send any extra messages, which greatly simplifies the commissining design for the joining node's application. Howerver, it does rely on certain intelligence and capabilities at the PAN's trust center device. Use of this method involves cooperation with the designer of the expected trust center (coordinator) node for your system.|

The choice of one of the above methods, or some variant thereof, will likely depend on the capabilities of the devices in your system, the importance of multi-vendor interoperability in your design, the expected latency of the commissioning process, and the sophistication of the installers who will be commissioning your devices. 

Zigbee provides a commissioning cluster in the ZCL, which facilitates over-the-air installation of certain commissioning parameters into a device. However, as of this writing neither the HA nor SE profile requires implementation of this cluster on client or server side in its device types, nor has its use been tested as part of the zigbee interoperability test events for these profiles. Use of the commissioning cluster is only feasible in networks where you can ensure that the joining node has server-side support for the commissioning cluster, and that at least one device in the system has client-side support to send commissioning commands. Furthermore, because the commissioning cluster relies on zigbee messaging, which necessitates being in a network in the first place, you would need to design a scheme for having your device join a temporary commissioning network where a commissioning tool exists that can provide the necessary parameters. While the application framework allows for use of the ZCL’s commissioning cluster, implementation of that cluster, if desired, is the responsibility of the application developer. 


### 3.2.4 Leave Mechanism
Many designers put careful thought into the network selection process and then neglect to provide a way for the system to uninstall the device from the current network and then install it into a new network. As the commissioning examples above show, enabling some way for the device to manually or automatically initiate an _emberLeaveNetwork()_ action, and possibly find a new network after the leave completes, is often necessary to facilitate successful installation and reinstallation of zigbee devices in their intended networks. 

If this cannot be implemented in the hardware or software of the joining device itself, the ZDO’s Leave Request mechanism, which is acted on automatically by the stack, may be a viable alternative, as it allows another node in the PAN, such as the network’s controller, to instruct a device to leave the network. For sample code implementing the ZDO Leave Request command, refer to the _emberLeaveRequest()_ API found in the “app/util/zigbee-framework/zigbee-device-common.h” file from your EmberZNet PRO installation. 

## 3.3 Device Discovery and Provisioning

Once you've joined your device to the correct network, it needs some way to be paired up with other nodes in the PAN that provide related services (in other words, client-side devices are paired up to one or more server-side side devices). This process of pairing together related devices in the PAN for communication at the application level is referred to as "provisioning". By contrast, "commissioning" deals with associating devices together for communication at the networking stack level. As you architect your design, consider how you will discover which and how many devices in your PAN provide the services (clusters) of interest and by what means you will provision those related devices to one another. Note that the actual provisioning process generally concludes with one or more of the involved devices each registering the partner device(s) into its binding table, its address table, or some custom storage mechanism designed to remember the provisioned partner, so that messages can be sent to that destination.

### 3.3.1 When to Discover and Provision

Often, application designer craft their application to perform some kind of device disovery, and attempt to provision soon after the commissioning prcess for a device is complete (that is , just after it comes online). However, because devices join one at a time, meaning one side of the provisioning is generally online before the other side, you will likely need to have a mechanism initialted by software state machine logic, external interrupt, or some over-the-air stimulus, to initiate provisioning later in the device's lifetime in the network.

Different provisioning methodes are described in the next sections, with advantages and disadvantages for each.

**Note:** If you are designing an application for use in an official, public zigbee PRO application profile such as zigbee 3.0, Silicon Labs recommends that you review the latest published revision of the appropriate zigbee PRO application profile specification (as obtained from <http://www.zigbe.or>) for your target design to ensure that any profile-specific requirements or best practices for provisioning are being met by your design.

### 3.3.2 Identify and Group Method(识别并分组方法)

This method can be used for one-to-one provisioning or one-to-mary provisioning, between a aingle device (usually a client for the cluters being provisoned) and one or more target devices (usually servers for the clusters being provisoned). It involves putting each of the target nodes into Identify mode either through reception of an Identify command from some device or through some external stimuls. The source node then sends an "Add Group If Identify" command (a required client command in the ZCL's Identify cluster) as a broadcast, such that all nodes currently in identification mode add themselves to the specified group through the groups table maintained by the ZCL Groups server cluster. Once the target devices belong to a single group, the source device can send multicasts to the group either directly (_EmberOutgoingMessageType_ of _EMBER_OUTGOING_DIRECT_) or by creating a Multicast binding for the target group and then sending outgoing commands through that binding (_EMBER_OUTGOING_VIA_BINDING_).
此方法可用于一对一的配置或一对多的配置，在单个源设备(通常为所提供的群集的客户端)和一个或多个目标设备(通常为所提供的群集的服务器)之间使用。它包括通过接收来自某个设备的识别命令或通过一些外部刺激将每个目标节点置于识别模式。源节点然后发送一个“Add group if Identify"命令(zcl标识集群中所需的客户端命令)作为广播，以便当前处于标识模式的所有节点通过zcl组服务器集群维护的 _Groups_ 表将自己添加到指定的组中。一旦目标设备属于单个组，源设备就可以将多播发送到组直接(_emberoutgoingmessagetype_ of _EMBER_OUTGOING_DIRECT_)或为目标组创建多播绑定，然后通过该绑定发送传出命令(_EMBER_OUTGOING_VIA_BINDING_)。

**Advantages:**
* Allows provisioning a single device to multiple target simultaneously(允许单个设备同时为向多个目标提供服务??).
* Requires as few as one over-the-air message (the Add Group If Identifying command) if all target devices support local method of being placed into Identify mode.
* Can be performed over a long or short time interval, as Identify Time used in the Identify command can be set very small or large. 
可以在很长或很短的时间间隔内执行，因为标识命令中使用的标识时间可以设置得非常小或很大。
* Can get devices into identification mode so that they are ready for provisioning in this manner over the air if needed, so works with devices without local stimulus (buttons or other user interface). 
可以使设备进入标识模式，以便在需要时可以在空中以这种方式提供设备，因此可以在没有本地刺激(按钮或其他用户界面)的设备上工作。
* If the source node can't be told manually to send Add Group If Identifying command, the source node can be put into identification mode and added to group so that multicast binding is created automatically (as part of groups table logic), for use in commissioning with target.

**Disadvantages**

* Target devices must support Groups server and Identify server clusters.
* Target devices may require local stimulus such as a button press to get into identification mode, unless another device in the system can be told to send Identify command to specific devices of interest. For example, a light swith needing connection to one or more lights could use a button press to enter a state where, for the next 30 seconds, any "Add to switch" messages sent by lights cause the switch to register a binding entry for those lights. Similarly, a button press (or other stimulus) could be used to cause these "Add to switch" messages to be transmitted by each light.
该方法包括在一个或多个设备上按下按钮，以使其发出其他设备可以识别为进行适当配置的信号的消息，或者进入在特定时间窗口内接收特定消息使其与发送方进行配置的状态。

### 3.3.3 Push Button Method

This method involves pressing a button on one or more of the devices to cause it either to emit a message that other devices can recognize as a signal to engage in provisioning with this devices as appropriate, or to enter a state where receiving a particular message within a particular time window causes it to engage in provisioning with the sender.
该方法包括在一个或多个设备上按下按钮，以使其发出其他设备可以识别为进行适当配置的信号的消息，或者进入在特定时间窗口内接收特定消息使其与发送方进行配置的状态。
For example, a light switch needing connection to one or more lights could use a button press to enter a state where, for the next 30 seconds, any “Add to switch” messages sent by lights cause the switch to register a binding entry for those lights. Similarly, a button press (or other stimulus) could be used to cause these “Add to switch” messages to be transmitted by each light.

**Advantages:**
* Lots of flexibility in implementation as for as what actions occur on button press and how long certain provisioning states last, which in turn impacts how long the provisioning process is allowed to take.
* CAn be used or one-to-one or one-to-more provisioning.
* Doesn't require involvement from any third party devices (those not on either side of the provisioning process).
* Allow's user/installer to explicity control the provisioning process through manual interaction.
* Doesn't need anyu special cluster support.
* May be used in conjunction with other provisioning methods that manual interaction, such as Identify and Group method.

**Disadvantages:**
* One or both sides of the provisioning require local stimulus, such as button, to engage in this process.
* May involve proprietary messaging protocal (for example, the proprietary "Add to switch" message discussed in the example above) or application-specific behavior to accomplish, reducing chances of interoperability among vendors.
* Provisioning between the wrong devices could occur if multiple provisioning processes are taking place simulteneously (such as if multiple installers are performing push-button provisioning on the same network at the same time).

## 3.3.4 Match Descriptor Request Method

In this method, a device looking to discover a particular partner for provisioning queries one or more through the ZDO Match Desciptor transaction to find a suitable provisioning partner based on the nodes' descriptor information (application profile, device identifier, cluster IDs, and client/server support) for each of their endpoints, In a typical scenario involving this method, a client device  for a particular cluster (cluster X), configured on application profile Y, sends out a ZDO Match Descriptor Request as a broadcast to the network, with the descriptor information specifying an endpoint with server support for cluster X on profile Y. All nodes that receive this request process the message automatically using code built into every standard zigbee PRO stack, by attempting to match the queried endpoint description with an endpoint descriptor on one of their own endpoints. If one or more endpoints on a queried device match the requested criteria, the queried device responds with a unicasted ZDO Match Descriptor Response containing the list of endpoints that match the request. The device that performed the query can then parse the responses and decide which (and how many) of the potential partners it should provision itself with.

**Advantages:**
* Provides for pairing based on a specific set of cluster support criteria.
* Doesnot require interaction of a third party to facilitate pairing (as compared with End Deivce Bind Method).
* Uses standard ZDO frames for query and response, allowing for an interoperable solution without special parsing required of the query and responses. Stack handles ZDO queries automatically.
* Query can be broadcast or unicast.

**Disadvantes:**
* Generally relies on broadcasts to find all nodes, which is not 100% reliable and consumes network bandwidth.
* When sent as a broadcast, the ZDO Match Descriptor Request can only be sent to the Rx-On-When-Idle broadcast address, meaning that sleepy (Rx off when Idle) end devices are not discoverable with this method.
* The application required some internal logic or a user interface to evaluate the query respondents and decide to which and to how many devices it should provision itself.
* Match Descriptor Responses may not contain the sender's EU64, so provisioning based on long addresses (rather than dynamic, 16-bit nodes IDs) may require and addtional unicast ZDO IEEE Address Request transcation to query the EUI64 of partner node.

### 3.3.5 Simple Descriptor Request Method
The Simple Desciptor Request method is similar to the Match Descriptor Request method in that it uses standard ZDO queries to inquire about the target node's endpoint configuration (profiles, clusters, server/client support, and so on). However, where the Match Descriptor Request is sent as a broadcast or a unicast to try matching cluster support criteria on the recipient devices, the Simple Descriptor Request is only sent as unicast to a specific endpoint of a target node, and produces a full list of supported client and server clusters available on that endpoint of the target. This request can be used iteratively on each available endpoint of the target node to discover all possible cluster support available across endpoints. A ZDO Active Endpoints Request is frequently used as a precursor to the ZDO Simple Descriptor transactions so that the querying device can know how many valid endpoints exist at the target node and their endpoint numbers. Although this method yields more complete information than the Match Descriptor Request method, it is also less efficient, and so is generally not practiacal to use when a large number of devices need to be queried. This method is most useful when the querying isn't sure which clusters it should provision with the target device; once it know which clusters are available on the partner device, it can choose from among those clusters as it completes the provisioning process.
简单描述符请求仅作为单播发送到目标节点的特定端点，并生成目标端点上可用的受支持客户端和服务器群集的完整列表。此请求可在目标节点的每个可用端点上迭代使用，以发现所有跨端点可用的群集支持。 一个 ZDO 活动端点请求经常用作 ZDO 简单描述符事务的前导，以便查询设备能够知道目标节点存在多少有效端点及其端点号。 虽然这种方法比匹配描述符请求方法生成更完整的信息，但是它的效率也较低，因此在需要查询大量设备时使用通常并不实用。当查询设备不确定它应该在目标设备中提供哪些集群时，这种方法最有用；一旦它知道伙伴设备上有哪些集群可用，它就会非常有用。在完成供应过程时，可以从这些集群中进行选择。

**Advantages:**
* Provides for pairing based on a specific set of cluster support criteria.
* Doesn't require interaction of a third party to facilitate pairing.
* Uses stardard ZDO frames for query and response, allowing for an interoperable solution without special parsing required of the query and responses. Stack handles ZDO queries automatically.
* Doesn't rely on broacast mechansim.
* Doesn't require that the querying device knows which clusters are expected on the target device.

**Disadvantages:**
* Requires lots of back-and-forth transcations (one command/response transcation per endpoint, plus one for the Active Endpoints Request to assess viable endpoint numbers) to discover endpoint data of the target. While bandwidth consumption is relatively low for these transactions, the latency in completing the provisioning process can be significant, especially if there are multiple endpoints on the target.
* The application requires some interal logic or a user interface to decode which nodes to query and what to do with the response data whaen it arrives.
* Simple Descriptor Responses may not contain the sender's EUI64, so provisioning based on long addresses (rather than dynamic, 16-bit node IDs) may require an additional unicast ZDO IEEE address Request transaction to query the EUI64 of the partner node. Note: Many devices will include their EUI64 in ZDO responses when the request is a unicast with the Source EUI64 APS option enabled, which is the default behavior for the EmberZNet PRO stack.

### 3.3.6 Provisioning Tool Method
In this method, a thrid party device (not one of the nodes being provisioned) obtains information about some or all of the devices in the network and then provides a user interface to allow the network's installer/administrator to provision devices to one another in whatever manner he deems appropriate. This device information may be acquired through one of the ZDO discovery processes described in the preceding sections (Simple Descriptor Request or Match Descriptor Request) or by some more proprietary means (similar to the way device information is provided by a network concentrator in the Device Advertisement method).

The provisioning tool may be a device dedicated to this role, or may also be fulfilling other central roles in the network, such as network concentrator, PAN coordinator, commissioning tool, or gateway. Since the provisioning tool is likely to be communicating with a lot of different devices in the network, Silicon Labs recommends make this node behave as a network concentrator so that routes to the other nodes are readily available without requiring a series of route discoveries, which can burden the network and increase latency.

Once the tool decides which devices should be provisioned to one another, it typically uses a ZDO Bind Request to the target devices to install a binding table entry for communication to the partner device.

**Advantages:**
* Provides for pairing based on user input for maximum flexibility in provisioning.
* Doesn't require any intelligence beyond standard ZDO support in stack in provisioned devices for information discovery. All intelligence resides in provisioning tool node.
* Provisioned devices don't need to be awake to do their own provisioning, so the provisioning process can occur while one of the provisioned devices is asleep.
* Devices don't need to worry about re-discoverying nodes for provisioning when new nodes enter the network, since the tool can take care of this.

**Disadvantages:**
* Requires a special tool (either a dedicated device or an extra set of functionality on an existing device) with a custom user interface to facilitate provisioning.
* The provisioning tool periodically needs to gaterh information from devices to avoid conflicting with the devices' own provisioning behaviors.

### 3.3.7 Address Dicovery
Since provisioning often involves the creation of a binding table or address table entry, which relies on an EUI64 for tracking devices, the nodes involved in provisioning should make an effort to obtain the EUI64 of their partner devices to facilitate these table entry creaions. For example, when using the Device Advertisement method, it is useful to include the advertiser's EUI64 to prevent the receiver from having to discover this later, should the receiver choose to provision itself to the advertiser. As another example, when using ZDO request methods such as Simple Descriptor Request and Match Descriptor Request methods, the request should, when possible, contain the source EUI64 of the requesting device so that the receiver can respond in kind by providing its EUI64 address in the response frame, allowing for smoother provisioning.

## 3.4 Route Establishment
In many networks, a larget amount of data is funneled to a single node that is designated to store the data or offload it to another system or network. This behavior is most common in large sensor networks where information is gathered from many devices and aggregated at some centrol point.

Many-to-One Routing (MTOR) allows an aggregation point (a "concentrator" in zigbee terminology) to provide every device on the network with a route to the concentrator without each node needing to discover it individually. Furthermore, MTOR provides a means to convery to the concentrator each node's own route to that concentrator. This allows the concentrator to collect some or all of these route records at its discretion, a techinque known as "source routing". MTOR works in conjunction with source routing to allow bidirectional communication between the concentrator and other nodes without requiring discovery of new or updated routes at the time of message delivery.

### 3.4.1 Background - Many to One Routing
Early in zigbee’s development, it became clear that a common communication pattern in embedded wireless networking applications was many-to-one, in which up to hundreds of devices might be communicating with a central gateway. At Silicon Labs, we sometimes use the term "aggregation" to refer to this pattern and the term "aggregator" for the gateway node. 
在ZigBee开发的早期，很明显，嵌入式无线网络应用程序中的一种常见的通信模式是多对一，其中多达数百台设备可能与中央网关通信。在硅实验室，我们有时使用术语“聚合”来指这种模式，而术语“聚合器”指的是网关节点。

### 3.4.2 How it Works in Zigbee PRO
This section briefly covers the details of how aggregation is now specified in the zigbee PRO network layer. 

The concentrator (for example, a gateway) establishes routes to itself by sending a many-to-one route request. This is just a regular route request sent to a special broadcast address. It signals the network layer of receiving nodes to create the inbound routes rather than a point-to-point route. No route replies are sent; the route record command frame described below serves a conceptually similar purpose.
集中器(例如，网关)通过发送多对一路由请求来建立到自己的路由。这只是发送到特定广播地址的常规路由请求。它向接收节点的网络层发送信号，以创建入站路由，而不是点对点路由。没有发送路由回复；下面描述的路由记录命令框架具有概念上类似的目的。

When a device sends a unicast to the concentrator, the network layer transparently takes care of sending a route record command frame to the concentrator first. As the route record packet is routed to the concentrator, the relay nodes append their short IDs to the command frame. By storing the route obtained from the route record payload, the concentrator is supplied with the information it needs to source route packets in the reverse direction.
当设备向集中器发送单播时，网络层首先负责向集中器发送路由记录命令帧。当路由记录分组被路由到集中器时，中继节点将其短ID附加到命令帧。通过存储从路由记录有效载荷中获得的路由，...

Source routing is accomplished by adding a subframe to the network frame, and setting a bit in the network frame control field. Upon receipt by relays, the next hop is read from the subframe rather than the local routing table. An application callback on the concentrator inserts the source route subframe into outgoing unicasts or APS acknowledgements as necessary.

Route maintenance is accomplished by the concentrator application resending the special many-to-one route request. 

You can find additional information in the online API reference guide and in the many FAQ articles available on the Silicon Labs Support Portal.

## 3.5 Message Delivery
